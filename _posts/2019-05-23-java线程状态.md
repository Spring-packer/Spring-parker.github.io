龍

---------------------
##### java 线程的6个状态：
参考笔记
1. 新建（New） ：使用new Thread() 创建一个线程之后。

2. 运行（Runnable） ：使用Thread.start() 方法之后。启动一个线程，该线程会进入等待队列等待CPU的执行，因此可以细分为runnable和running状态。

3. 无限等待（waiting） ：处于这种状态的线程，不会被分配CPU执行时间，需要等待其他线程显式地唤醒，然后进入运行状态。

- 调用Thread.join() 方法。将会一直等待上一个线程的执行结束，然后被上一个线程唤醒。
- 调用Object.wait() 方法。将会一直等待，直到其他线程中使用了notify()、notifyAll()进行唤醒。
4. 有限等待（timed waiting） ：处于这种状态的线程，不会被分配CPU执行时间，既可以被其他线程显式地唤醒，也可以在一定时间后由系统自动唤醒，然后进入运行状态。

 - 调用Thread.sleep(timeout) 方法。该方法不会释放持有的对象锁。
 - 调用Object.wait(timeout) 方法。该方法会释放持有的锁。
 - 调用Thread.join(timeout) 方法。
5. 阻塞（blocked） ：阻塞和等待的区别在于，阻塞是在等待获取一个排它锁，因为该线程获取不到锁所以被阻塞住而不能允许；而等待则是等待一段时间或者是等待被唤醒，等待状态并不是等待获取锁。这个状态有个特点，一个线程请求锁，得到之后该线程进入阻塞状态；而其他线程再来请求锁，由于得不到而阻塞；当该锁释放后，被阻塞的线程得到锁就进入了运行状态。

- 由synchronized 修饰的代码块、方法。使得线程之间有并行变成串行执行。
IO操作，也是串行执行。
6. 结束（terminated） ：当线程的run() 方法执行结束后，该线程就结束了。

 ![Image](https://spring-packer.github.io/parker/imgs/xiancheng.png)
 
---