龍


### 内存泄漏
+ [常发性内存泄漏](#partI)
+ [偶发性内存泄漏](#partII)
+ [一次性内存泄漏](#partIII)
+ [隐式内存泄漏](#partIIII)

----------------------------------

### 常规问题

这里是第一部分的内容
高并发多线程 / 内存溢出内存泄漏 /redis为什么快  / mongo是怎么存储数据 /
红黑树 /索引的数据结构 / 为什么用了索引能加快速度 / b+树是怎么找到对应索引的 / jvm的内存分配


----------------------------------

## <a id='partI'>第一部分</a>
 
 1. 常发性内存泄漏
 指：发生内存泄漏的代码被多次执行，每次执行
 都会出现内存泄漏。
 
 2. 偶发性内存泄漏
 指：发生内存泄漏的程序只在特殊环境和特殊操
 作中才会发生，常发性和偶发性相对，对于特定
 的环境，偶发性的也许就变成了常发性的。所以
 测试环境和测试方法对检测内存泄漏至关重要。
 3. 一次性内存泄漏
 指：发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。
 4. 隐式内存泄漏
 指：程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 


```

 `内存泄漏的危害，在于泄漏的堆积，这会导致系统内存的内存溢出。
所以一次性内存泄漏无害，偶发性和常发性有害，隐式内存泄漏危害非常大，
因为它很难被检测到。`

```

----------------------------------
## <a id='partIII'>第二部分</a>
内存泄漏最终导致内存溢出，内存溢出的原因和解决方法。
### 原因
1. 内存加载的数据量过于庞大
2. 集合类中有对对象的引用 使用完没清空 使得JVM不能回收
3. 代码中有死循环或者循环中产生过多重负的对象实体
4. 使用的第三方软件中有BUG
5. 启动参数内存之设置的过小

### 解决方案
第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)

第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。

第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。

#### 重点排查以下几点：
1.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。

2.检查代码中是否有死循环或递归调用。

3.检查是否有大循环重复产生新对象实体。

4.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。

5.检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。

第四步，使用内存查看工具动态查看内存使用情况

  
  

  
  
  
  